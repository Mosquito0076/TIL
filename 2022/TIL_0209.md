# LIST

### 1. 알고리즘

1. 무엇이 좋은 알고리즘인가?
   1. 정확성 : 얼마나 정확하게 동작하는가
   2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
   3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
   4. 단순성 : 얼마나 단순한가
   5. 최적성 : 더 이상 개선할 여지없이 최적화 되었는가
2. 시간 복잡도
   - 실제 걸리는 시간을 측정
   - 실행되는 명령문의 개수를 계산
   - Big - Oh Notation(빅 - 오 표기법)
     - 시간 복잡도 함수 중에서 가장 큰 영향령을 주는 n에 대한 항 만을 표시
     - 계수는 생략하여 표시
     -  O() notation



---

### 2. 배열(List)

1. 배열이란

   - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

   - ```python
     # 일정한 자료형의 변수들
     Num0 = 0
     Num1 = 1
     Num2 = 2
     
     # 하나의 이름으로 열거하여 사용하는 자료구조
     Num = [0, 1, 2]
     ```

   - 자료 접근의 효율성

   - 하나의 선언을 통해 둘 이상의 변수 선언

   - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음



---

### 3. 정렬(Sort)

1. 정렬
   - 2개 이상의 자료를 특정 기준에 의해 작은 값 부터 큰 값(오름차순, ascending), 혹은 그 반대의 순서대로(내림차순, decending) 재배열하는 것
   - 키: 자료를 정렬하는 기준이 되는 특정 값
   - 대표적인 정렬 방식의 종류
     - 버블 정렬 (Bubble Sort)
     - 카운팅 정렬 (Counting Sort)
     - 선택 정렬 (Selection Sort)
     - 퀵 정렬 (Quick Sort)
     - 삽입 정렬 (Insertion Sort)
     - 병합 정렬 (Merge Sort)



|  알고리즘   | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 |                           비고                           |
| :---------: | :-----------: | :-----------: | :-----------: | :------------------------------------------------------: |
|  버블 정렬  |     O(n²)     |     O(n²)     |  비교 + 교환  |                   코딩이 가장 손쉽다.                    |
| 카운팅 정렬 |    O(n+k)     |    O(n+k)     |    비교환     |              n이 비교적 작을 때만 가능하다.              |
|  선택 정렬  |     O(n²)     |     O(n²)     |  비교 + 교환  |       교환의 회수가 버블,<br />삽입 정렬보다 작다.       |
|   퀵 정렬   |  O(n log n)   |     O(n²)     |   분할 정복   | 최악의 경우 O(n²) 이지만,<br />평균적으로는 가장 빠르다. |
|  삽입 정렬  |     O(n²)     |     O(n²)     |  비교 + 교환  |              n의 개수가 작을 때 효과적이다.              |
|  병합 정렬  |  O(n log n)   |  O(n log n)   |   분할 정복   |          연결리스트의 경우 가장 효율적인 방식.           |

