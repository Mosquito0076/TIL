# 컴퓨터 구조 - 1. 디지털 논리 회로

### 1. 디지털 논리 회로

![image](https://user-images.githubusercontent.com/95673624/215315085-0a49dd8c-4402-4627-ab86-2d660e02dd80.png)

- 디지털 컴퓨터
  - **이진 시스템**을 사용하여 **계산**을 수행하는 디지털 시스템
  - **비트의 그룹(0, 1)**을 사용하여 숫자, 문자 및 기타 **정보를 표시하거나 처리**
- 컴퓨터 하드웨어
  - CPU - **중앙처리장치**. 일반적으로 '**컴퓨터 그 자체**'로 정의. **산술 논리** 처리와 **데이터의 저장, 제어** 기능 수행
  - 주변 장치 - CPU를 제외한 **나머지**, 메모리(RAM/ROM), 저장 장치(Storage), 입출력 장치 (IO devices)

- 컴퓨터 소프트웨어
  - **운영체제**(OS, Operating System)
    - 하드웨어, 소프트웨어 **전체를 관리하는 소프트웨어**
    - 사용자가 **컴퓨터를 쉽게** 다룰 수 있도록 해주는 시스템
  - **시스템 프로그램**
    - 유틸리티, 데이터베이스, Editor 등
    - **OS에 포함**되거나, 연결되어 **시스템 운영을 보조**
  - 응용 프로그램
    - 그 외 나머지

<br>

### 2. 논리 게이트

![image](https://user-images.githubusercontent.com/95673624/215315456-186279ca-9113-49d4-a3d0-5b94db5a1483.png)

- 이진 정보의 표시
  - 일반적으로 0과 1을 의미하는 전압 신호로 각각 표현됨
  - 0V - 5V 시스템과 0.5V - 3V 시스템이 있지만, 일반적으로 전자를 많이 써서 **0은 0V, 1은 5V**로 사용됨
- 논리 게이트
  - 이진 시스템의 동작 원리
  - 더 복잡한 기능들을 구성하는 **기본적인 게이트**
  - 진리표로 동작을 정의한다

<br>

### 3. 부울 대수

![image](https://user-images.githubusercontent.com/95673624/215317966-5a0d8c9f-fcb9-4b57-a555-cc334e3f1020.png)

- **이진 변수와 논리 동작**을 취급하는 **대수(수학적 구조) 체계**
- 기본적인 부울 대수 동작
  - AND (*)
  - OR (+)
  - NOT (\')
- 부울 대수의 사용 이유
  - **변수 사이의** 진리표 **관계**를 **대수적으로 표시**할 수 있다
  - 논리도의 **입출력 관계**를 **대수 형식으로 표시**할 수 있다
  - 같은 기능을 가진 **더 간단한 회로**를 찾을 수 있다
- 부울 대수의 기본 관계
  - 항등원
  - 역원
  - 교환 법칙
  - 결합 법칙
  - 드 모르간의 법칙

![image](https://user-images.githubusercontent.com/95673624/215318114-e1f7a637-086a-4266-98f2-6d13e4e31b9c.png)

![image](https://user-images.githubusercontent.com/95673624/215318147-19fe0c1f-0144-4dd0-8c00-2c2b97186f88.png)

- 부울 대수는 위와 같이 더 **간략한 등가 회로**를 찾을 수 있다
  - 회로 부품이나 길이에 따라 비용이 더 들 수 있고, 시간이 더 걸릴 수 있으므로 **오른쪽이 더 효율적**이다.

<br>

### 4. 맵의 간소화

- 맵 방식의 부울 함수(수식) 간소화
  - 부울 대수의 대수적 성질을 통해 부울 함수를 간소화 할 수도 있지만, **항이 많아지면** 이를 파악하기 힘들다
  - 따라서 부울 함수를 **visual diagram**을 통해서 간소화 하는 것을 **맵 간소화** 라고 한다
  - 일반적으로 Karnaugh map, Vietch diagram등의 **map diagram을 통해 간소화** 한다

- 카르노 맵 간소화

![image](https://user-images.githubusercontent.com/95673624/215320036-2697d33d-c048-43a7-980c-6f0552955567.png)

- 우선 위와 같이 카르노 맵을 만든다
  - 변수가 여러 개여도 상관이 없으며, 각각의 값이 1인 경우와 1인 경우의 위치를 숫자로 표시할 수 있다
  - 좌측 변수를 앞의 자리, 우측 변수를 뒤의 자리로 해서 숫자를 만들면, 총 2^n 개의 숫자를 차례대로 써서 표현이 가능하다



![image](https://user-images.githubusercontent.com/95673624/215320064-c722da79-59fb-4e63-93c6-1042e6582f6a.png)

- 다음으로, 실제로 모든 경우의 값을 넣어보았을 때 부울 함수가 1을 출력하는 경우를 찾아, 이를 맵에 표시한다

  - 이를 통해 두 개 이상의 1이 붙어있는 곳을 함수로 표현하면 된다
  - 단, 여기서 모든 테두리는 이어져 있다고 생각해도 된다(C' 또는 B' 등 같은 값을 가진 위치이기 때문)

  ![image](https://user-images.githubusercontent.com/95673624/215321198-3b30c28e-e7ad-44c2-9e0f-7ea1179a0c25.png)

- 위와 같이 Maxterm(1)을 기준으로 간소화 할 수도 있지만, Minterm(0)을 기준으로 간소화 할 수도 있다
  - 단, 출력이 0인 함수를 만드는 것이므로 F가 구해지는 것이 아니라 F'를 구하는 것
  - 따라서 만든 후 함수를 다시 드 모르간의 법칙을 이용하여 뒤집어 주어야 한다
  - 결국 위 두 함수(회로)는 동치이다

- 무정의 조건(Don't Care Conditon)

![image](https://user-images.githubusercontent.com/95673624/215321586-7f2d53eb-3604-40ea-9312-31610ca2a34b.png)

- **사용하지 않는 항**을 의미함
- 이를 이용해서 간소화 할 수 있음. 해당 항은 무슨 값이 들어가도 상관 없기 때문(0이든 1이든 없는 곳이기 때문에 **실제 연산과 무관계**하다)
- 이것을 이용해서 함수를 만든 경우, 일반적으로는 동치(같은 결과를 냄)이지만, 엄밀하게는 동치가 아님